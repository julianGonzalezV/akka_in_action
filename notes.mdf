
-Nace por la nececidad de hacer algo con la concurrencia y poder scalar 

scaling up: Vertical se trata de aumentar recursos, aprovechar los que hay ejemplo 
Threads son solo en scaling up
sacaling out or Horizontal scaling se trata de más server en el cluster

-Recordar que los llamados a BD, otro contexto, son side effects 
-Journal como tipo de base de datos para almacenar todos los eventos que han pasado y event sourcin como técnica a usar para que al momento de que se caiga el sistema se pueda volver a retormar o re-hacer
la historia.


-Sharding como divisón o particionamiento de tareas más grandes


Polling es cuando preguntamos cada x tiempo por un recurso (disponibilidad, nueva información etc)
-  La idea de akka es hacer push a los clientes acerca del suceso de un Evento x
- Los eventos desacoplan los componentes de un sistema
- publish-subscribe mechanism

The event-driven approach solves the polling problem
Comunicacion entre Objetos con mensajes, ya que los objetos deben manejar su propio estado interno, en lugar de que algo externo lo afecte
Muchas veces a un componente no le interesa si otro se cae, ya que el componente hace lo que él debe hacer PERO al usuario, cliente, aplicación si se le deha hacer 
saber de que un componente se cae, para reiniciarlo por ejemplo, AHÍ ES CUANDO APLICA LA ESTRATEGIA SE SUPERVISOR E HIJOS 


EL supervisor decide si continuar, reiniciar el componente(objeto o actor), por ejemplo si el que está caido es el compoenente ppal entonces stop, pero si es el componente de envío de correos
entonces envié a reiniciar a ver si funciona :) 


PARALELISMO habla de realizar procesos simultáneamente 
Concurrencia habla de procesos que pueden coincidir en el tiempo, pero no necesariaemte CORREN SIMULTÁNEAMENTE, ejemplo en un mismo cpu y cada uno tiene su participacipón en 
el tiempo.

Sí la aplicacion la pensamos para scalar en varios server entonces debe ser asincrona la comunicacion (pg 36)
Imagine el supervisor siendo Síncrono y esperando por la respuesta de cada uno se sus hijos (para todo el aplicativo )

lOS Actores no permiten acceso a estado interno

Actor Operations:
create, send, become, and supervise

En objetos  hemos visto toda la vida que es posible alterar el estado entre objetos, con actores NO!, la comunicacipón es solo por mensajes que la mayor parte de l tiempo son 
fire and forget, si se requiere respeusta entonces devolver un acknowledge message.

An actor can create other actors

BECOME: Los actores pueden ca,biar su comportamiento(dependiendo del mensaje que se el envió por ejemplo) 
S UPERVISE: Supervisar los actores que un el mismo actor supervisor crea

lO primero que hace un sistema cuando se levan ta es crear el ActorSystem

A scheduler can send messages to actors periodically


Messages are sent to the actor’s ActorRef




When an actor crash the supervisor has four options when deciding
what to do with the actor:
 Restart—The actor must be re-created from its Props. After it’s restarted (or
rebooted, if you will), the actor will continue to process messages. Since the rest
of the application uses an ActorRef to communicate with the actor, the new
actor instance will automatically get the next messages.
 Resume—The same actor instance should continue to process messages; the
crash is ignored.
 Stop—The actor must be terminated. It will no longer take part in processing
messages.
 Escalate—The supervisor doesn’t know what to do with it and escalates the problem
to its parent, which is also a supervisor.


deadLettersActorRef: Is a special ActorRef that receives all messages that are sent to dead actors.


Supervision Strategies:
The OneForOneStrategy determines that child actors won’t share the same

AllForOneStrategy: Uses the same decision for all child actors even if only one crashed.

stoppingStrategy: It will stop any child that crashes on any Exception.

supervisor Strategies:::
Resume the child, ignore errors, and keep processing with the same actor
instance.
 Restart the child, remove the crashed actor instance, and replace it with a fresh
actor instance.
 Stop the child and terminate the child permanently.
 Escalate the failure and let the parent actor decide what action needs to be taken.


Cuando se tiene case Terminated(`logProcessor`)  con ése estilo de comillas quiere decir que 
cuando se termine (especie del kill) el actor logProcessor entonces debohacer algo, como por ejemplo también terminar el 
actor actual (ver pg 89 la real 106 la del pdf del libro, note como FileWatcher se termina al recibir el mensaje terminate de props , mediante monitoring, ojo monitoring -watch and unwatch es diferente a Supervision)


Promise[T]: A promise can be used to wrap a callback API
val future: Future[RecordMetadata] = promise.future
val callback = new Callback() {
def onCompletion(metadata: RecordMetadata, e: Exception): Unit = {
if (e != null) promise.failure(e)
else promise.success(metadata)
}
}
producer.send(record, callback)
future
}

DefaultPromise. DefaultPromise is built to be used
from several threads at the same time

::::::5.3 Futuristic errors(page 104 real):::::::::::::::
con futureFail.onComplete podemos obtener el error de un futuro 

Fatal exceptions are never handled by a future.

Cuando alguna funcion o método retorna UNIT no se puede seguir encadenando el computo (pensando en esto, es como el void de java)

Usamos case clases para representar estructuras del negocio , al usar "case" estamos asegurando que son estructuras inmutables y la idea
es que sea así, sino corremos el riesgo de compartir el mismo objeto en futuros (Future) diferentes, share mutable state.


Pero a pesar de que no se pueda continuar con el computo, se puede hacer uso de un recover method:
The recover method will replace
the failed Future with a TicketInfo
with an empty route inside
a new Future.
This method makes it possible to
define what result must be returned when exceptions occur.

getTraffic(ticketInfo).recover {
case _: TrafficServiceException => ticketInfo
}

sí getTraffic se ejecuta correctamente entonces el retorna lo que debe retornar (en este ejemplo del libro por ejemplo es un Future[TicketInfo])
pero si falla entonces 

:::::5.4 Combining futures:::::::::
La programación funcional ofrece otros combinators para Futuros:

Future.firstCompletedOf: retorna el resultado del primer servicio que respondió (see oa 110 real), ojo puede responder fallo o success
Y si nos queremos blindar entonces unsamos la función find PARA filtrar los que terminaron exitosamente





Fold: 

Zip: 

Traverse artists:




::::::::::::::::::::::::::::::::::
